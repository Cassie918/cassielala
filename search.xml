<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CSS counter属性]]></title>
    <url>%2F2019%2F01%2F28%2Fcss-counter%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[前言 本文引用张鑫旭大大博客文章《CSS counter计数器(content目录序号自动递增)详解》，一直觉得鑫大大是个被程序员耽误的小说家，他的文章风格大都以浅明深，诙谐幽默，可点击这里查看原文哦。 好了，It’s my show time!在了解到counter之前，想到计数应该属ul，ol标签元素了吧，但它们的递增规则单一，无法实现自定义的递增。而counter属性完美的解决了这个问题，让我们一起来看看吧。首先，使用一个属性前，我们一定得了解一下它的兼容性，曾经被IE兼容性虐哭的我，不得不小心作为一个好用属性的兼容问题。 兼容性 &nbsp;I&nbsp;E&nbsp;&nbsp; Firefox Chrome Safari Opera iOS Safari Android Browser Android Chrome 8.0+ 2.0+ 4.0+ 3.1+ 3.5+ 3.2+ 2.1+ 18.0+ &emsp;&emsp;看到这里是不是心里放松了很多，它的兼容性还是可以的接受的，范围不算局限。 counter的使用题要 CSS计数器只能跟content属性在一起的时候才有作用，而content属性貌似专门用在before/after伪元素上的。于是，就有了，“计数器↔伪元素↔content属性”的铁三角关系 counter成员counter的成员主要有三个： counter-reset（计数器声明及初始值设置） counter-increment（递增规则） counter()/counters(计算结果生成) counter-resetcounter-reset主要有三个属性。 none：默认。不能对选择器的计数器进行重置。 name num：name即标记计数器名称，num即记录计数器初始值。num非必写，默认为0。 inherit：规定应该从父元素继承 counter-reset 属性的值。 counter-incrementcounter-increment主要有三个属性。 none：没有计数器将递增。 name num：name即选择递增的计数器，num即增量。num非必写，默认为1，可以是正数、零或者负数。 inherit：指定counter-increment属性的值，应该从父元素继承。 counter()/counters()这是个方法，不是属性。类似CSS3中才calc()计算。 name：选择递增的计数器。 style：递增的数字样式：阿拉伯数字，罗马数字等，具体如下： list-style-type：disc | circle | square | decimal | lower-roman | upper-roman | lower-alpha | upper-alpha | none | armenian | cjk-ideographic | georgian | lower-greek | hebrew | hiragana | hiragana-iroha | katakana | katakana-iroha | lower-latin | upper-latin string：counters的属性，子序数连接符 注：多个计数器还可同时命名，接下来我们上代码看几个例子。 123456789101112131415161718192021222324252627282930CSS：1. counter-reset属性.xxx &#123; counter-reset: count; /* 计数器名称是'count', 并且默认起始值为0 */&#125; .xxx &#123; counter-reset: count 4; /* 计数器名称是'count', 并且默认起始值为4 */&#125; .xxx &#123; counter-reset: count1 2 count2 3; /* 定义两个计数器'count1'和'count2',默认起始值分别为2和3 */&#125; 2. counter-increment属性.counter &#123; counter-increment: count 2; /*'count'以2阶段递增 */&#125;.counter &#123; counter-increment: count -1; /*'count'以1阶段递减 */&#125;3. counter方法counters(name, style);.counter:before &#123; content: counter(count1) '\A' counter(count2); /*'\A'使用inline水平元素换行*/ white-space: pre; &#125; &emsp;&emsp;接下来看一个完整的例子。效果如图：12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;div class="box"&gt; &lt;div class="list"&gt;一级标题 &lt;div class="box"&gt; &lt;div class="list"&gt;二级标题&lt;/div&gt; &lt;div class="list"&gt;二级标题&lt;/div&gt; &lt;div class="list"&gt;二级标题&lt;/div&gt; &lt;/div&gt; &lt;div class="box"&gt; &lt;div class="list"&gt;二级标题 &lt;div class="box"&gt; &lt;div class="list"&gt;三级标题&lt;/div&gt; &lt;div class="list"&gt;三级标题&lt;/div&gt; &lt;div class="list"&gt;三级标题&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;div class="list"&gt;一级标题&lt;div&gt;&lt;/div&gt;&lt;style&gt;.box &#123; counter-reset: counter; &#125;.toper, .inner &#123; background-color: #eee; margin-left: 20px; &#125;.list:before, .toper:before,.inner:before &#123; counter-increment: counter; &#125;.list &#123; padding-left: 20px;&#125;.inner:before, .list:before, .toper:before &#123; content: counters(counter,'.')'、';&#125;&lt;/style&gt; OK~至此，关于counter的介绍就差不多结束了，可以在实践过程中发现和挖掘更有意思的操作，如果你有什么有趣的神操作，可以给我留言分享哦！啦啦啦~]]></content>
      <categories>
        <category>Front-End Learning</category>
        <category>HTML/CSS</category>
      </categories>
      <tags>
        <tag>Front-End Learning</tag>
        <tag>HTML/CSS</tag>
        <tag>css counter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS counter属性]]></title>
    <url>%2F2019%2F01%2F28%2Fcss%2F</url>
    <content type="text"><![CDATA[前言 本文引用张鑫旭大大博客文章《CSS counter计数器(content目录序号自动递增)详解》，一直觉得鑫大大是个被程序员耽误的小说家，他的文章风格大都以浅明深，诙谐幽默，可点击这里查看原文哦。 好了，It’s my show time!在了解到counter之前，想到计数应该属ul，ol标签元素了吧，但它们的递增规则单一，无法实现自定义的递增。而counter属性完美的解决了这个问题，让我们一起来看看吧。首先，使用一个属性前，我们一定得了解一下它的兼容性，曾经被IE兼容性虐哭的我，不得不小心作为一个好用属性的兼容问题。 兼容性 &nbsp;I&nbsp;E&nbsp;&nbsp; Firefox Chrome Safari Opera iOS Safari Android Browser Android Chrome 8.0+ 2.0+ 4.0+ 3.1+ 3.5+ 3.2+ 2.1+ 18.0+ &emsp;&emsp;看到这里是不是心里放松了很多，它的兼容性还是可以的接受的，范围不算局限。 counter的使用题要 CSS计数器只能跟content属性在一起的时候才有作用，而content属性貌似专门用在before/after伪元素上的。于是，就有了，“计数器↔伪元素↔content属性”的铁三角关系 counter成员counter的成员主要有三个： counter-reset（计数器声明及初始值设置） counter-increment（递增规则） counter()/counters(计算结果生成) counter-resetcounter-reset主要有三个属性。 none：默认。不能对选择器的计数器进行重置。 name num：name即标记计数器名称，num即记录计数器初始值。num非必写，默认为0。 inherit：规定应该从父元素继承 counter-reset 属性的值。 counter-incrementcounter-increment主要有三个属性。 none：没有计数器将递增。 name num：name即选择递增的计数器，num即增量。num非必写，默认为1，可以是正数、零或者负数。 inherit：指定counter-increment属性的值，应该从父元素继承。 counter()/counters()这是个方法，不是属性。类似CSS3中才calc()计算。 name：选择递增的计数器。 style：递增的数字样式：阿拉伯数字，罗马数字等，具体如下： list-style-type：disc | circle | square | decimal | lower-roman | upper-roman | lower-alpha | upper-alpha | none | armenian | cjk-ideographic | georgian | lower-greek | hebrew | hiragana | hiragana-iroha | katakana | katakana-iroha | lower-latin | upper-latin string：counters的属性，子序数连接符 注：多个计数器还可同时命名，接下来我们上代码看几个例子。 123456789101112131415161718192021222324252627282930CSS：1. counter-reset属性.xxx &#123; counter-reset: count; /* 计数器名称是'count', 并且默认起始值为0 */&#125; .xxx &#123; counter-reset: count 4; /* 计数器名称是'count', 并且默认起始值为4 */&#125; .xxx &#123; counter-reset: count1 2 count2 3; /* 定义两个计数器'count1'和'count2',默认起始值分别为2和3 */&#125; 2. counter-increment属性.counter &#123; counter-increment: count 2; /*'count'以2阶段递增 */&#125;.counter &#123; counter-increment: count -1; /*'count'以1阶段递减 */&#125;3. counter方法counters(name, style);.counter:before &#123; content: counter(count1) '\A' counter(count2); /*'\A'使用inline水平元素换行*/ white-space: pre; &#125; &emsp;&emsp;接下来看一个完整的例子。效果如图：12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;div class="box"&gt; &lt;div class="list"&gt;一级标题 &lt;div class="box"&gt; &lt;div class="list"&gt;二级标题&lt;/div&gt; &lt;div class="list"&gt;二级标题&lt;/div&gt; &lt;div class="list"&gt;二级标题&lt;/div&gt; &lt;/div&gt; &lt;div class="box"&gt; &lt;div class="list"&gt;二级标题 &lt;div class="box"&gt; &lt;div class="list"&gt;三级标题&lt;/div&gt; &lt;div class="list"&gt;三级标题&lt;/div&gt; &lt;div class="list"&gt;三级标题&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;div class="list"&gt;一级标题&lt;div&gt;&lt;/div&gt;&lt;style&gt;.box &#123; counter-reset: counter; &#125;.toper, .inner &#123; background-color: #eee; margin-left: 20px; &#125;.list:before, .toper:before,.inner:before &#123; counter-increment: counter; &#125;.list &#123; padding-left: 20px;&#125;.inner:before, .list:before, .toper:before &#123; content: counters(counter,'.')'、';&#125;&lt;/style&gt; OK~至此，关于counter的介绍就差不多结束了，可以在实践过程中发现和挖掘更有意思的操作，如果你有什么有趣的神操作，可以给我留言分享哦！啦啦啦~]]></content>
      <categories>
        <category>Front-End Learning</category>
        <category>HTML/CSS</category>
      </categories>
      <tags>
        <tag>Front-End Learning</tag>
        <tag>HTML/CSS</tag>
        <tag>css counter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2019%2F01%2F22%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;数据/字符串处理是工作中经常能用到的，以前的做法大都是通过百度然后修改别人的代码完成字符串处理，一直想系统的跟正则认识一番，于是有了这篇。&emsp;&emsp;再次非常感谢雪峰大大和鑫大大的文章支持，点击以下链接可查看原文。&emsp;&emsp;雪峰大大的 标准对象/RegExp.&emsp;&emsp;鑫大大的 粉丝群第27期JS基础小测答疑文字版&emsp;&emsp;好的，接下来进入正题啦。 正则表达式定义&emsp;&emsp;正则表达式是对字符串操作的一种逻辑公式，用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。举个例子：&emsp;&emsp;’00\d’可以匹配’007’，‘008’，其中‘\d’即匹配数字。 语法元字符 &nbsp;字&nbsp;符&nbsp;&nbsp; 描&nbsp;述 &nbsp;反义字符&nbsp;&nbsp; 描&nbsp;述 $ 匹配输入字符串的结尾位置 ^ 匹配输入字符串的开始位置 . 匹配除换行符 \n 之外的任何单字符 \b 匹配单词边界 \B 匹配不是单词开头或结束的位置 \d 匹配数字 \D 匹配任意非数字的字符 \w 匹配字母，数字，下划线 \W 匹配任意不是字母，数字，下划线 的字符 \s 匹配空格 \S 匹配任意不是空白符的字符 [abc] 匹配包含括号内元素的字符 [^abc] 匹配除了abc以外的任意字符 量词 &nbsp;字&nbsp;符&nbsp;&nbsp; 描&nbsp;述 &nbsp;带?字符&nbsp;&nbsp; 描&nbsp;述 * 重复至少0次 *? 重复任意次,但尽可能少重复 + 重复至少1次 +? 重复至少1次,但尽可能少重复 ? 重复0次或1次 ?? 重复0次或1次,但尽可能少重复 {n} 重复n次 {n,} 重复至少n次 {n,}? 重复至少n次,但尽可能少重复 {n,m} 重复n-m次 {n,m}? 重复n-m次,但尽可能少重复 特殊字符 &nbsp;字&nbsp;符&nbsp;&nbsp; 描&nbsp;述 &nbsp;字&nbsp;符&nbsp;&nbsp; 描&nbsp;述 \cx 匹配由x指明的控制字符。 \f 匹配一个换页符。等价于 \x0c 和 \cL。 ( ) 标记一个子表达式的开始和结束位置。 \n 匹配一个换行符。等价于 \x0a 和 \cJ。 &#124; 指明两项之间的一个选择，或 \r 匹配一个回车符。等价于 \x0d 和 \cM。 [ 标记一个中括号表达式的开始 \s 匹配任何空白字符，包括空格、制表符、换页符等等。 \ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符 \S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。 { 标记限定符表达式的开始。 \t 匹配一个制表符。等价于 \x09 和 \cI。 \v 匹配一个垂直制表符。等价于 \x0b 和 \cK。 举例说明 数字、字母匹配（\d匹配数字，\w匹配任意字母，数字，下划线）可用00\d可以匹配007\d\d\d可以匹配任意三位数字，如：123\w\d\w可以匹配l0l .匹配任意字符，则any.可匹配anya、anyb、anyc、anyd …… 配合上量词再看看\d{3}表示匹配3个数字，例如010\d{3,8}表示3-8个数字，例如1234567 再加上我们的范围[0-9a-zA-Z\_]可以匹配一个数字、字母或者下划线[0-9a-zA-Z\_]+可以匹配至少由一个数字、字母或者下划线组成的字符串，比如a100，0_Z，Py3000等等[a-zA-Z\_][0-9a-zA-Z\_]*可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量[a-zA-Z\_][0-9a-zA-Z\_]{0, 19}更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符） 啊，还有我们的选择字符和定位A|B可以匹配A或B，所以(P|p)ython可以匹配Python或者python^表示行的开头，^\d表示必须以数字开头$表示行的结束，\d$表示必须以数字结束 你可能注意到了，py也可以匹配python，但是加上^py$就变成了整行匹配，就只能匹配py了 字符串的切割 最常用的应该就是split切割了，但是当字符串之间不仅仅是单一字符连接，切割就会出现问题，比如下面的例子 123456789101112 //出现多余空格情况： 'a b c'.split(' '); // ['a', 'b', '', '', 'c']//嗯，无法识别连续的空格，用正则表达式试试：'a b c'.split(/\s+/); // ['a', 'b', 'c']//无论多少个空格都可以正常分割。加入,试试：'a,b, c d'.split(/[\s\,]+/); // ['a', 'b', 'c', 'd']//再加入;试试：'a,b;; c d'.split(/[\s\,\;]+/); // ['a', 'b', 'c', 'd']//如果用户输入了一组标签，下次记得用正则表达式来把不规范的输入转化成正确的数组。 字符串的分组应用除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group）。比如：^(\d{3})-(\d{3,8})$分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码： 123var re = /^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$/;re.exec('010-12345'); // ['010-12345', '010', '12345']re.exec('010 12345'); // null 如果正则表达式中定义了组，就可以在RegExp对象上用exec()方法提取出子串来。exec()方法在匹配成功后，会返回一个Array，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。exec()方法在匹配失败时返回null。 提取子串非常有用。来看一个更凶残的例子： 12var re = /^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$/;re.exec('19:05:30'); // ['19:05:30', '19', '05', '30'] 这个正则表达式可以直接识别合法的时间。但是有些时候，用正则表达式也无法做到完全验证，比如识别日期： 1var re = /^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$/; 对于’2-30’，’4-31’这样的非法日期，用正则还是识别不了，或者说写出来非常困难，这时就需要程序配合识别了。 以下内容参见鑫大大博客内容： 中英文之间需要增加空格首先，我们的思路应该是“中文”、“英文”、“空格”，于是我们可得到&emsp;/(中文+英文+|英文+中文+)/g&emsp;这样的符号表达转换成正则符号即:&emsp;/([\u4e00-\u9fa5]+[A-Za-z]+|[A-Za-z]+[\u4e00-\u9fa5]+)/g其中[\u4e00-\u9fa5]表示中文字符匹配；[A-Za-z]表示全部的英文字母。斜杠后面的g表示全局匹配，除了g，还有i和m。其中i表示不区分大小写，m表示支持多行匹配。这里的括号和加号可化简，则最终可表达为：&emsp;/[\u4e00-\u9fa5][a-z]|[a-z][\u4e00-\u9fa5]/gi 全角标点与其他字符之间不加空格这里如果直接用正则表达式，会显得冗余且不易懂，故使用RegExp对象简化 123456// 全角标点字符们 var strPunct = '！（）【】『』「」《》“”‘’；：，。？、'; // 使用管道符连接 var regPunct = strPunct.split('').join('|'); // 此时的正则表达式 new RegExp('['+ regPunct +'] +| +['+ regPunct +']', 'g'); 这样就显得简洁多了其中，空格使用普通空格字符进行匹配的，而不是\s，这样可以避免把换行符也过滤掉了 不重复使用标点符号这里的标点指中文标点，因为英文标点不重复，有些不切实际，例如空字符串’’，就是合法的重复标点。使用正则表达式： 1/(\~|\`|\!|\[|\]|\&#123;|\&#125;|\;|\:|\"|\'|\,|\&lt;|\.|\&gt;|\/|\?|\！|\·|\【|\】\「\」|\；|\：|\“|\”|\，|\《|\。|\》|\、|\？)\1+/g 使用RegExp对象简化： 1new RegExp(`($&#123;regPunct&#125;)\\1+`, 'g') 这样就是不使用重复中文标点了。其中，这里的\1有必要好好说下。\1表示捕获匹配，表示捕获第一个分组括号中匹配的值，你可以理解为代称。在正则表达式中，每一个分组括号()都自带一个看不见的序号，从前往后依次是分组一，分组二，分组三……这里的\1就表示匹配的第一个标点，后面跟了个+则表示，这里重复标点2个或多个都匹配。捕获分组不仅存在于正则表达式中，当我们使用replace方法进行正则替换的时候，也存在与替换方法中，使用美元符号$外加数字表示，例如前后空格过滤trim()方法的简易polyfill： 123456if (!''.trim) &#123; String.prototype.trim = function () &#123;// $1表示第一个()中匹配的值return this.replace(/^\s*(.*?)\s*$/, '$1'); &#125;;&#125; 其中’$1’并不是替换成字符串$1意思，而是替换成第一个()中匹配的值，在这里表示首尾空格以外的值。 如果我们需要对捕获分组内容进行额外处理，可以把第二个参数作为function处理，例如： 12345this.replace(/^\s*(.*?)\s*$/, function (matches, $1) &#123; // matches表示完整匹配内容（包括前后空格） // $1则表示第一个()中匹配的值 // 此时就可以对$1进行处理，返回我们需要的值&#125;) 破折号前后需要增加一个空格这个比较简单，可直接获得： 1/\S——|——\S/g 使用全角中文标点正则表达式 1/([^A-Za-z][\~|\`|\!|\[|\]|\&#123;|\&#125;|\;|\:|\"|\'|\,|\&lt;|\.|\&gt;|\/|\?][^A-Za-z])/g 使用RegExp对象处理： 12345var strPunctHalf = '!()[]"\';:,.?';// 不同于全角字符，半角字符需要加转义var regPunctHalf = strPunctHalf.split('').join('|\\');// 此时的正则表达式new RegExp(`[\u4e00-\u9fa5][a-z]*( *[$&#123;regPunctHalf&#125;] *)|( *[$&#123;regPunctHalf&#125;] *)[a-z]*[\u4e00-\u9fa5]`, 'gi'); 数字使用半角/[\uFF10-\uFF19]+/g 遇到完整的英文整句，其內容使用半角标点正则表达式 1/(\「[A-Za-z\s\~|\`|\!|\;|\:|\"|\'|\,|\&lt;|\.|\&gt;|\/|\?]*[\！|\·|\；|\：|\“|\”|\，\。|\、|\？][^\」]*\」)|(\《[A-Za-z\s\~|\`|\!|\;|\:|\"|\'|\,|\&lt;|\.|\&gt;|\/|\?]*[\！|\·|\；|\：|\“|\”|\，\。|\、|\？][^\》]*\》)/g RegExp对象处理: 1new RegExp(`([a-z]+[$&#123;regPunct&#125;|\\s])+[a-z]*([$&#123;regPunct&#125;|\\s][a-z]+)+`, 'gi') &emsp;&emsp;正则表达式的介绍就先到这里啦，怎么样，动手使用吧~~~]]></content>
      <categories>
        <category>Front-End Learning</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Front-End Learning</tag>
        <tag>JavaScript</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[敢问施主因何而来]]></title>
    <url>%2F2019%2F01%2F16%2Fhello-world%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;个人习惯，来到一个新的地方总是喜欢先来个开篇，阐述一下因由。&emsp;&emsp;作为一个思绪如钢丝球的伪文艺女青年，我总能在某个奇怪的点在肚子里用仅有的墨水哗哗哗的长篇论述一番，并自我感觉异常良好，这篇淡墨水文或是段子，或是感思，或是记人，或是叙事，有时也可能仅是想描个景。每每这时我都特别的想发个朋友圈或是空间说说反馈我难以抑制的感觉，但又怕显得琐碎，矫情，于是默默地吞进肚子，然后被消化到淡忘。&emsp;&emsp;于是来此，畅叙一番，不为什么，就怕话痨的我被程序员的静默给憋出内伤，哈哈哈哈哈哈哈哈哈哈啊。&emsp;&emsp;当然，也希望在这里能够记录我的学习历程，平常会有些记笔记的习惯，但是缺少整理和系统的归纳，再者希望通过公共学习和更多的人交流，发现自己的陋习和问题。&emsp;&emsp;这里大致给自己列了一个目录的提纲，诶哟喂，希望能够满满的丰富起来呀~~~&emsp;&emsp;Fighting！ 胡啦啦家的大墨池 碎碎念 记人 叙事 矫情话二三 Front-End Learning HTML/CSS JavaScript Vue React Angular Node DataBase Webpack Else 啦啦 is here 音乐 电影 字词句段篇章 电视剧 彩铅 美食 旅游 蹦跶蹦跶dance~（估计这会是个空置项，哈哈哈 &emsp;&emsp;最后！首篇福利，给大家看一张我超爱的图片，超级cute！！！因而最后的结果被我截图制成了头像，哇啊啊啊啊，老夫的少女心啊。]]></content>
      <categories>
        <category>胡啦啦家的大墨池</category>
        <category>碎碎念</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
      </tags>
  </entry>
</search>
