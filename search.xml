<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[写给自己看的SQL摘抄]]></title>
    <url>%2F2019%2F02%2F12%2F%E5%86%99%E7%BB%99%E8%87%AA%E5%B7%B1%E7%9C%8B%E7%9A%84SQL%E6%91%98%E6%8A%84%2F</url>
    <content type="text"><![CDATA[本文来源于廖雪峰的SQL教程，由于是写给自己看的知识点汇总，所以简单的介绍类文字可能就不介绍了，直接上干货。点击这里可查看廖雪峰教程原址。 关系模型主键 概念：指能够唯一区分出不同记录的字段称之为主键。 主键选取原则：不使用任何业务相关的字段作为主键。主键：身份证号、手机号、邮箱地址（X）主键：自增整数类型id（√）因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响，假设以身份证号为主键，当身份证号升位了，或者需要变更，作为主键，不得不修改的时候，就会对业务产生严重影响。所以要避免使用业务相关字段作为主键。如下表，id为学生信息主键： id class_id name gender score 1 1 小明 M 90 2 1 小红 F 95 外键 概念：将本表数据关联另一张表的字段称之为外键。 定义外键约束： 1234ALTER TABLE studentsADD CONSTRAINT fk_class_id /* 外键约束名称 */FOREIGN KEY (class_id) /* 定义外键字段 */REFERENCES classes (id); /* 将外键关联到`classes`表的`id`列 */ 删除外键 12ALTER TABLE studentsDROP FOREIGN KEY fk_class_id; 索引 概念：索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。 id class_id name gender score 1 1 小明 M 90 2 1 小红 F 95 3 1 小军 M 88 如果要经常根据score列进行查询，就可以对score列创建索引： 12ALTER TABLE studentsADD INDEX idx_score (score); 使用ADD INDEX idx_score (score)就创建了一个名称为idx_score，使用列score的索引。索引名称是任意的，索引如果有多列，可以在括号里依次写上，例如： 12ALTER TABLE studentsADD INDEX idx_name_score (name, score); 索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。反过来，如果记录的列存在大量相同的值，例如gender列，大约一半的记录值是M，另一半是F，因此，对该列创建索引就没有意义。 可以对一张表创建多个索引。索引的优点是提高了查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢。 对于主键，关系数据库会自动对其创建主键索引。使用主键索引的效率是最高的，因为主键会保证绝对唯一。 查询基本数据准备，students表和classes表 id class_id name gender score 1 1 小明 M 90 2 1 小红 F 95 3 1 小军 M 88 4 1 小米 F 73 5 2 小白 F 81 6 2 小兵 M 55 7 2 小林 M 85 8 3 小新 F 91 9 3 小王 M 89 10 3 小丽 F 85 id name 1 一班 2 二班 3 三班 4 四班 条件查询查询所有数据SELECT * FROM &lt;表名&gt;12/* 查询students表的所有数据 */SELECT * FROM students; 按条件查询SELECT * FROM &lt;表名&gt; WHERE &lt;条件表达式&gt;与：AND或：OR非：NOT或者&lt;&gt; 123456789101112131415/* 分数在80分或以上的学生 */SELECT * FROM students WHERE score &gt;= 80; /* 分数在80分以上的男生 */SELECT * FROM students WHERE score &gt;= 80 AND gender = 'M';/* 分数在80分以上或男生 */SELECT * FROM students WHERE score &gt;= 80 OR gender = 'M';/* 不是2班的学生 */SELECT * FROM students WHERE NOT class_id = 2;=&gt;SELECT * FROM students WHERE class_id &lt;&gt; 2;/* 多条件查询 */SELECT * FROM students WHERE (score &lt; 80 OR score &gt; 90) AND gender = 'M'; 投影查询使用SELECT返回指定列，这种操作称为投影。SELECT语句可以对结果集的列进行重命名。12345/* 从students表中返回id、score和name这三列 */SELECT id, score, name FROM students;/* 将列名score重命名为points，而id和name列名保持不变 */SELECT id, score points, name FROM students; 排序语法：ORDER BY升序：ASC，默认升序降序：DESC1234567891011121314/* 按score从低到高 */SELECT id, name, gender, score FROM students ORDER BY score; /* 按score从高到低 */SELECT id, name, gender, score FROM students ORDER BY score DESC;/* 如果score列有相同的数据，进一步按gender排序 */SELECT id, name, gender, score FROM students ORDER BY score DESC, gender;/* 带WHERE条件的ORDER BY:ORDER BY子句要放到WHERE子句后面，这样，结果集仅包含符合WHERE条件的记录，并按照ORDER BY的设定排序。 */SELECT id, name, gender, scoreFROM studentsWHERE class_id = 1ORDER BY score DESC; 分页查询 语法：LIMIT &lt;M&gt; OFFSET &lt;N&gt; LIMIT：pageSize OFFSET：pageSize * (pageIndex - 1)，OFFSET超过了查询的最大数量并不会报错，而是得到一个空的结果集。 在MySQL中，LIMIT 15 OFFSET 30还可以简写成LIMIT 30, 15。 123456789/* 每页3条记录(LIMIT 3)，要获取第n页的记录(OFFSET (n-1)*3) */SELECT id, name, gender, scoreFROM studentsORDER BY score DESCLIMIT 3 OFFSET 0; /* 第1页 *//*LIMIT 3 OFFSET 3; 第2页 LIMIT 3 OFFSET 6; 第3页 LIMIT 3 OFFSET 9; 第4页 */ 聚合查询 COUNT:表示查询的行数 SUM 计算某一列的合计值，该列必须为数值类型 AVG 计算某一列的平均值，该列必须为数值类型 MAX 计算某一列的最大值，不限于数值类型 MIN 计算某一列的最小值，不限于数值类型 注:如果聚合查询的WHERE条件没有匹配到任何行，COUNT()会返回0，而MAX()、MIN()、MAX()和MIN()会返回NULL： 1234567891011/* 查询students表一共有多少条记录,返回结果仍然是一个二维表，只是这个二维表只有一行一列，并且列名是COUNT(*) */SELECT COUNT(*) FROM students;/* 使用聚合查询并设置结果集的列名为num */SELECT COUNT(*) num FROM students;/* 统计男生人数 */SELECT COUNT(*) boys FROM students WHERE gender = 'M';/* 计算男生平均成绩 */SELECT AVG(score) average FROM students WHERE gender = 'M'; GROUP BY：分组聚合 12/* 统计每个班人数 */SELECT class_id, COUNT(*) num FROM students GROUP BY class_id; 结果集如下： class_id num 1 4 2 3 3 3 注：聚合查询的列中，只能放入分组的列。比如我们可以以班级、性别分组计数，但不可以以姓名计数，会得到语法错误。 多表查询 语法：SELECT * FROM &lt;表1&gt; &lt;表2&gt;12/* students表和classes表的“乘积” */SELECT * FROM students, classes; 以上乘积查询存在问题： 结果集是目标表的行数乘积，返回数据量倍增 存在重复同名列 要解决这个问题，可以利用投影查询的“设置列的别名”来给两个表各自的id和name列起别名，如下：123456789/* students表和classes表的“乘积” */SELECT students.id sid, students.name, students.gender, students.score, classes.id cid, classes.name cnameFROM students, classes; 简略查询表名：12345678SELECT s.id sid, s.name, s.gender, s.score, c.id cid, c.name cnameFROM students s, classes c; 添加where条件：12345678910/* “乘积”条件中同时符合s.gender = 'M'和c.id = 1 */SELECT s.id sid, s.name, s.gender, s.score, c.id cid, c.name cnameFROM students s, classes cWHERE s.gender = 'M' AND c.id = 1; 连接查询连接查询是另一种类型的多表查询。对多个表进行JOIN运算，先确定一个主表作为结果集，然后，把其他表的行有选择性地“连接”在主表结果集上。12345/* 选出所有学生，同时返回班级名称 */SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.scoreFROM students sINNER JOIN classes cON s.class_id = c.id; 注意INNER JOIN查询的写法是： 确定主表，仍然使用FROM &lt;表1&gt;的语法； 确定需要连接的表，使用INNER JOIN &lt;表2&gt;的语法； 确定连接条件，使用ON &lt;条件...&gt;，这里的条件是s.class_id = c.id，表示students表的class_id列与classes表的id列相同的行需要连接； 可选：加上WHERE子句、ORDER BY等子句。 几种连接： INNER JOIN：选出两张表都存在的记录由于students表的class_id包含1，2，3，classes表的id包含1，2，3，4，所以，INNER JOIN根据条件s.class_id = c.id返回的结果集仅包含1，2，3。 LEFT OUTER JOIN：选出左表存在的记录如果我们给students表增加一列，并添加class_id=5，由于classes表并不存在id=5的列，所以，LEFT OUTER JOIN的结果会增加一列，对应的class_name是NULL RIGHT OUTER JOIN：选出右表存在的记录如果某一行仅在右表存在，那么结果集就会以NULL填充剩下的字段。 FULL OUTER JOIN：选出左右表都存在的记录 修改数据新增 语法：INSERT INTO &lt;表名&gt; (字段1, 字段2, ...) VALUES (值1, 值2, ...);123INSERT INTO students (class_id, name, gender, score) VALUES(1, '大宝', 'M', 87),(2, '二宝', 'M', 81); 修改 语法：UPDATE &lt;表名&gt; SET 字段1=值1, 字段2=值2, ... WHERE ...;1234UPDATE students SET name='小牛', score=77 WHERE id&gt;=5 AND id&lt;=7;/* 还可以用表达式，把所有80分以下的同学的成绩加10分 */UPDATE students SET score=score+10 WHERE score&lt;80; 删除 语法：DELETE FROM &lt;表名&gt; WHERE ...; 12/* 删除id=5,6,7的记录 */DELETE FROM students WHERE id&gt;=5 AND id&lt;=7; 注： 如果WHERE条件没有匹配到任何记录，DELETE语句不会报错，也不会有任何记录被删除 DELETE语句可不加WHERE，不带WHERE条件的DELETE语句会删除整个表的数据，要谨慎使用 MySQL操作管理MySQL语句 123456789101112131415161718192021222324252627282930313233/* 显示现有数据库 */SHOW DATABASES;/* 创建一个新数据库 */CREATE DATABASE DBName;/* 删除一个数据库 */DROP DATABASE DBName;/* 切换数据库 */USE DBName;/* 列出当前数据库的所有表 */SHOW TABLES;/* 查看一个表的结构 */DESC students;/* 命令查看创建表的SQL语句 */SHOW CREATE TABLE students;/* 删除表 */DROP TABLE students;/* 修改表--新增列 */ALTER TABLE students ADD COLUMN birth VARCHAR(10) NOT NULL;/* 修改表--修改列 */ALTER TABLE students CHANGE COLUMN birth birthday VARCHAR(20) NOT NULL;/* 修改表--删除列 */ALTER TABLE students DROP COLUMN birthday;/* 退出MySQL */EXIT 实用SQL语句插入或替换如果记录已经存在，就先删除原记录，再插入新记录，反之直接插入记录。使用REPLACE语句1REPLACE INTO students (id, class_id, name, gender, score) VALUES (1, 1, '小明', 'F', 99); 若id=1的记录不存在，REPLACE语句将插入新记录，否则，当前id=1的记录将被删除，然后再插入新记录。 插入或更新如果记录已经存在，就更新该记录，反之直接插入记录。使用INSERT INTO ... ON DUPLICATE KEY UPDATE ...语句1234INSERT INTO students (id, class_id, name, gender, score) VALUES (1, 1, '小明', 'F', 99) ON DUPLICATE KEY UPDATE name='小明', gender='F', score=99; 若id=1的记录不存在，INSERT语句将插入新记录，否则，当前id=1的记录将被更新，更新的字段由UPDATE指定。 插入或忽略如果记录已经存在，就啥事也不干直接忽略，反之直接插入记录。使用INSERT IGNORE INTO ...语句1INSERT IGNORE INTO students (id, class_id, name, gender, score) VALUES (1, 1, '小明', 'F', 99); 若id=1的记录不存在，INSERT语句将插入新记录，否则，不执行任何操作。 快照对一个表进行快照，即复制一份当前表的数据到一个新表，可以结合CREATE TABLE和SELECT12-- 对class_id=1的记录进行快照，并存储为新表students_of_class1CREATE TABLE students_of_class1 SELECT * FROM students WHERE class_id=1; 新创建的表结构和SELECT使用的表结构完全一致。 写入查询结果集如果查询结果集需要写入到表中，可以结合INSERT和SELECT，将SELECT语句的结果集直接插入到指定表中。例如，创建一个统计成绩的表statistics，记录各班的平均成绩：123456CREATE TABLE statistics ( id BIGINT NOT NULL AUTO_INCREMENT, class_id BIGINT NOT NULL, average DOUBLE NOT NULL, PRIMARY KEY (id)); 然后，我们就可以用一条语句写入各班的平均成绩：1234INSERT INTO statistics (class_id, average) SELECT class_id, AVG(score) FROM students GROUP BY class_id; 确保INSERT语句的列和SELECT语句的列能一一对应，就可以在statistics表中直接保存查询的结果：123456789&gt; select * from statistics;+----+----------+--------------+| id | class_id | average |+----+----------+--------------+| 1 | 1 | 86.5 || 2 | 2 | 73.666666666 || 3 | 3 | 88.333333333 |+----+----------+--------------+3 rows in set (0.00 sec)]]></content>
      <categories>
        <category>Front-End Learning</category>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>Front-End Learning</tag>
        <tag>DataBase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计时器：setTimeout, setInterval]]></title>
    <url>%2F2019%2F02%2F11%2F%E8%AE%A1%E6%97%B6%E5%99%A8%EF%BC%9AsetTimeout-setInterval%2F</url>
    <content type="text"><![CDATA[异步执行由来&emsp;&emsp;由于JS是单线程，同一时间只能执行一个任务。当同时发起多个任务时根据任务发起先后顺序需要排队，后续任务必须等到前一个任务结束才能开始执行。为了避免因为某些长时间任务造成的无意义等待，JS引入了异步的概念，用另一个线程来管理异步任务。&emsp;&emsp;同步任务直接在主线程队列中顺序执行，而异步任务会进入另一个任务队列，不会阻塞主线程。等到主线程队列空了（执行完了）的时候，就会去异步队列查询是否有可执行的异步任务了（异步任务通常进入异步队列之后还要等一些条件才能执行，如ajax请求、文件读写），如果某个异步任务可以执行了便加入主线程队列，以此循环。&emsp;&emsp;JS中的计时器使用的就是异步操作。接下来我们分别看看setInterval和setTimeout的用法。 语法 语法 12var intervalID = setInterval(code, delay); var intervalID = setTimeout(code, delay); 参数解释 参数 含义 intervalID 定时器id，标识该定时器 func 执行函数，其中setInterval()是按照指定的delay时间来调用函数或计算表达式。方法会不停地调用函数，直到定时器被关闭。而setTimeout()是在delay毫秒数后调用函数或计算表达式。 delay 延迟的毫秒数 (一秒等于1000毫秒) 简单例子 12345678910111213141516&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;title&gt;setTimeout&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"/&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;setTimeout：&lt;/h1&gt; &lt;span id="content"&gt;三秒后显示3&lt;/span&gt; &lt;script&gt; setTimeout(function () &#123; let content = document.getElementById('content'); content.innerHTML = "&lt;div&gt;3&lt;/div&gt;"; &#125;,3000); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 3秒后，span中的内容就变成了3。 1234567891011121314151617&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;title&gt;setInterval&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"/&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;setInterval&lt;/h1&gt; &lt;span id="content"&gt;计时&lt;/span&gt; &lt;script&gt; var i = 0; var time = setInterval(function () &#123; let content = document.getElementById('content'); content.innerHTML = "&lt;div&gt;"+(i++)+"&lt;/div&gt;"; &#125;,1000); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 1秒后，span中的内容从0开始计时。 setTimeout传参数问题 由于setTimeout的属于异步，有时配合点击事件或指定问题会取不到值，所以，接下来我们看一个传参问题。 点击setTimeout传参数问题查看原文。 废话不多说，直接上代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;head&gt; &lt;title&gt;setTimeout&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"/&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;setTimeout&lt;/h1&gt; &lt;span id="content"&gt;测试&lt;/span&gt; &lt;button id="stopBtn" onclick="timeClick(this)"&gt;stop&lt;/button&gt; &lt;script&gt; var i = 0; /*var stopBtn = document.getElementById('stopBtn');*/ setTimeout(function () &#123; let content = document.getElementById('content'); content.innerHTML = "&lt;div&gt;setTimeout"+(i++)+"&lt;/div&gt;"; console.log("setTimeout"); &#125;,1000); var time = setInterval(function () &#123; let content = document.getElementById('content'); content.innerHTML = "&lt;div&gt;setInterval"+(i++)+"&lt;/div&gt;"; console.log("setInterval"); &#125;,1000); /*stopBtn.onclick = function()&#123; clearInterval(time); &#125;*/ function timeClick(obj) &#123; obj.style.backgroundColor="gray";; obj.onclick=function()&#123; clearInterval(time); &#125; setTimeout(function()&#123;resetbgColor(obj);&#125;,3000); &#125; function resetbgColor(obj) &#123; obj.style.backgroundColor=""; obj.onclick=function()&#123; timeClick(this); &#125;; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果如图：左边为按钮点击前，右边为按钮点击后，三秒后按钮背景色恢复。 定时器清除：clearTimeout()、clearInterval()clearTimeout()、clearclearInterval()分别对应setTimeout()和setInterval()，取消对应的定时器。上例中有体现，这里不再赘述，但要注意关闭指定定时器的id，避免重新启动定时器导致定时出错。注： HTML5标准规定，setTimeout的最短时间间隔是4毫秒；setInterval的最短间隔时间是10毫秒，也就是说，小于10毫秒的时间间隔会被调整到10毫秒 大多数电脑显示器的刷新频率是60HZ，大概相当于每秒钟重绘60次。因此，最平滑的动画效的最佳循环间隔是1000ms/60，约等于16.6ms 链式调用setTimeout()使用setInterval()的问题在于，定时器代码可能在代码再次被添加到队列之前还没有完成执行，结果导致定时器代码连续运行好几次，而之间没有任何停顿。而javascript引擎对这个问题的解决是：当使用setInterval()时，仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中。这确保了定时器代码加入到队列中的最小时间间隔为指定间隔。这样会导致两个问题： 某些间隔被跳过 多个定时器的代码执行之间的间隔可能比预期的小 为解决上述问题，可采取链式调用setTimeout()方法。如下：123setTimeout(function fn()&#123; setTimeout(fn,interval);&#125;,interval); 这个模式链式调用了setTimeout()，每次函数执行的时候都会创建一个新的定时器。第二个setTimeout()调用当前执行的函数，并为其设置另外一个定时器。这样做的好处是，在前一个定时器代码执行完之前，不会向队列插入新的定时器代码，确保不会有任何缺失的间隔。而且，它可以保证在下一次定时器代码执行之前，至少要等待指定的间隔，避免了连续的运行。接下来，我们来看setInterval()和链式调用setTimeout()来实现同一个效果的两种方式。12345678910111213141516171819202122232425262728&lt;!--使用setInterval()--&gt;&lt;div id="myDiv" style="height: 100px;width: 100px;background-color: pink;position:absolute;left:0;"&gt;&lt;/div&gt;&lt;script&gt;myDiv.onclick = function()&#123; var timer = setInterval(function()&#123; if(parseInt(myDiv.style.left) &gt; 200)&#123; clearInterval(timer); return false; &#125; myDiv.style.left = parseInt(myDiv.style.left) + 5 + 'px'; &#125;,16); &#125;&lt;/script&gt;&lt;!--链式调用setTimeout()--&gt;&lt;div id="myDiv" style="height: 100px;width: 100px;background-color: pink;position:absolute;left:0;"&gt;&lt;/div&gt;&lt;script&gt;myDiv.onclick = function()&#123; setTimeout(function fn()&#123; if(parseInt(myDiv.style.left) &lt;= 200)&#123; setTimeout(fn,16); &#125;else&#123; return false; &#125; myDiv.style.left = parseInt(myDiv.style.left) + 5 + 'px'; &#125;,16); &#125;&lt;/script&gt; 效果：点击如下方块时，方块从左往右移动205px； 本文参考文章： setTimeout传参数问题深入理解定时器系列第一篇——理解setTimeout和setInterval]]></content>
      <categories>
        <category>Front-End Learning</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Front-End Learning</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阮一峰前端技术栈教程]]></title>
    <url>%2F2019%2F01%2F30%2F%E6%8A%80%E6%9C%AF%E6%A0%88%2F</url>
    <content type="text"><![CDATA[ES6 语法:点击查看 Babel：点击查看 React：点击查看&emsp;示例库 Webpack：点击查看 React 项目脚手架：点击查看 Flex 布局：点击查看&emsp;示例 CSS Modules：点击查看&emsp;示例库 React-Router：点击查看&emsp;示例库 Flux 架构：点击查看&emsp;示例库 Redux 架构：教程一&emsp;教程二&emsp;教程三 Mocha 测试框架：点击查看&emsp;示例库 Istanbul 覆盖率框架：点击查看 React 单元测试：点击查看&emsp;示例库]]></content>
      <categories>
        <category>Front-End Learning</category>
        <category>Else</category>
      </categories>
      <tags>
        <tag>Front-End Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown语法小记]]></title>
    <url>%2F2019%2F01%2F29%2Fmarkdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[基本语法标题h1~h6对应： #数量决定标题等级。还可以用=在文字下表示，但局限只有两级。12345678910# h1## h2### h3#### h4##### h5###### h6 一级标题===二级标题--- 显示如下： 引用12&gt; 引用的文字&gt;&gt; 引用的文字 大于号越多，引用的层级越多，上述代码显示效果如下： 引用的文字 引用的文字 链接或图片12[点击跳转至百度](http://www.baidu.com)![图片](http://cassielala.top/images/logo.jpg) 显示效果如下：点击跳转至百度&nbsp;&nbsp; hexo插入本地图片使用hexo的时候因为要插入本地图片遇到了问题，特此写来记录，希望能够帮助到大家。 首先将hexo把主页的配置文件_config.yml 里的post_asset_folder:这个选项设置为true hexo目录下执行npm install hexo-asset-image --save 完成后再new新的md文件的时候就能在/source/_posts下找到同名文件夹，将要放的图片丢进去对应的文件夹。 md文件中引入的时候使用![xxx](xxx/xxx.png)即可 本来到这里应该就万事大吉了，但是嘞，我的图片依旧无法显示，后来经过我一系列的搜索，终于找到了问题的解决方案。问题：图片依然无法显示的原因是hexo3版本更新后对很多插件支持有问题，hexo-asset-image插件在处理data.permalink链接时出现路径错误，把年月去掉了，导致最后生成的路径为%d/xxx/xxx。做法： 找到插件hexo-asset-image,通过判断当前版本是否等于3的版本做不同的路径分割，一般插件在/node_modules/目录下。 修改代码如下： 12345678//可在方法上添加该变量var version = String(hexo.version).split('.');//修改“data.permalink”var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, '/', 1) + 1; else var beginPos = getPosition(link, '/', 3) + 1; md文件使用时直接写照片名即可。 修改完成保存，重新生成静态文件即可：![xxx](xxx.png)。 列表 无序列表使用*、+、-标识 有序列表使用数字加.标识，例如：1. 可嵌套使用，回车+tab即可 1234567891011121314151617181920212223* 黄瓜* 玉米* 茄子+ 黄瓜+ 玉米+ 茄子- 黄瓜- 玉米- 茄子1. 黄瓜2. 玉米3. 茄子- 黄瓜 - 水果黄瓜 - 小黄瓜- 玉米 - 紫玉米 - 黄玉米- 茄子 效果如下： 黄瓜 玉米 茄子 黄瓜 玉米 茄子 黄瓜 水果黄瓜 小黄瓜 玉米 紫玉米 黄玉米 茄子 注： 如果在单一列表项中包含了多个段落，为了保证渲染正常，*与段落首字母之间必须保留四个空格。 如果在列表中加入了区块引用，区域引用标记符也需要缩进4个空格 反正记住一个原则，如果在和列表配合使用的时候出现了问题，就缩进一次，四个空格或者一个制表符代表一次缩进。如果一次缩进没有解决问题，那就两次。 分割线使用*或-即可12***--- 效果如下： 强调12345*这里是斜体*_这里是斜体_**这里是加粗**__这里是加粗__ 效果如下：这里是斜体这里是斜体这里是加粗这里是加粗 插入代码块使用两排的“1234```\```javaXXXXXX```\ 插入表格其中第一行表头，第二行定义排列方式，:居--坐边即左对齐，居右则右对齐，两边都有则居中。123表头|条目一|条目二:---:|:---:|:---:项目|项目一|项目二 效果如下： 表头 条目一 条目二 项目 项目一 项目二 符号处理转译多加一个/123456789101112\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 支持高亮语言 名称 关键字 名称 关键字 AppleScript applescript ActionScript 3.0 actionscript3, as3 Shell bash , shell ColdFusion coldfusion,cf C cpp , c C# c# , c-sharp , csharp CSS css Delphi delphi , pascal , pas diff&amp;patch diff patch Erlang erl , erlang Groovy groovy Java java JavaFX jfx , javafx JavaScript js , jscript , javascript Perl perl , pl , Perl PHP php text text , plain Python py , python Ruby ruby , rails , ror , rb SASS&amp;SCSS sass , scss Scala scala SQL sql Visual Basic vb , vbnet XML xml , xhtml , xslt , html Objective C objc , obj-c F# f# f-sharp , fsharp xpp , dynamics-xpp R r , s , splus matlab matlab swift swift GO go , golang 大致介绍就到这里啦，如果有什么新的发现，我会继续更新哒！]]></content>
      <categories>
        <category>Front-End Learning</category>
        <category>Else</category>
      </categories>
      <tags>
        <tag>Front-End Learning</tag>
        <tag>Else</tag>
        <tag>markDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ag-Grid 超丰富的表格插件（1）——简易使用]]></title>
    <url>%2F2019%2F01%2F28%2Fag-Grid-%E8%B6%85%E4%B8%B0%E5%AF%8C%E7%9A%84%E8%A1%A8%E6%A0%BC%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[由于最近一直接触的ag-Grid，但是网上的博文却很少见，有些困惑想搜索却找不到答案，不晓得为什嘛，所以想写一些常见的功能介绍，也能和大家一起探讨一下。作为经历过手写table表格的我，ag-Grid带给我的感受简直不要不要的，感觉是一款功能超级丰富表格插件，因为没用过其他什么table表格插件，所以不能说它是最好用的。说不上如何深挖，请叫我亲爱的的翻译官吧，毕竟翻墙是一种痛，每次一个网页加载出来，都不舍得刷新重新了O(∩_∩)O哈哈~。ag-Grid官方文档上有详细的属性、方法说明介绍，且配有案例和代码以及在线编辑功能，十分强大。想看官方网站原址可点击这里查看哦。好吧，接下来让我们看看这个神奇的ag-Grid。 安装ag-Grid有两种版本，一个是community，还有一个是企业级的enterprise版本，并不知道干嘛的，我们直接安装ag-Grid就好了。 NPM安装ag-Grid： 1$ npm install --save ag-grid community、enterprise： 12npm install --save ag-grid-communitynpm install --save ag-grid-enterprise 本地下载可点击这里下载源文件直接本地使用 头文件引入12&lt;link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css"/&gt;&lt;script src="https://unpkg.com/ag-grid-community@20.0.0/dist/ag-grid-community.min.js"&gt;&lt;/script&gt; 使用1、首先，在HTML里添加表格插入的div容器1&lt;div id="myGrid" style="height: 150px;width: 600px" class="ag-theme-balham"&gt;&lt;/div&gt; 2、头文件引入表格文件和样式文件123import &#123;Grid&#125; from "ag-grid/main";import "ag-grid/dist/styles/ag-grid.css";import "ag-grid/dist/styles/ag-theme-balham.css"; 3、配置表格列和行数据123456789101112const gridOptions = &#123; columnDefs: [ &#123;headerName: 'Make', field: 'make'&#125;, &#123;headerName: 'Model', field: 'model'&#125;, &#123;headerName: 'Price', field: 'price'&#125; ], rowData: [ &#123;make: 'Toyota', model: 'Celica', price: 35000&#125;, &#123;make: 'Ford', model: 'Mondeo', price: 32000&#125;, &#123;make: 'Porsche', model: 'Boxter', price: 72000&#125; ]&#125;; 4、初始化表格12let eGridDiv = document.querySelector('#myGrid');new Grid(eGridDiv, this.gridOptions); 5、大功告成！然后可得到如下表格是不是很迅速很过瘾？！！！可能你会说其他很多表格组件也都如此，没什么特别的，不要方，这才刚开始，花式玩表格等着你！！！]]></content>
      <categories>
        <category>Front-End Learning</category>
        <category>Else</category>
      </categories>
      <tags>
        <tag>Front-End Learning</tag>
        <tag>好用的插件</tag>
        <tag>ag-Grid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS counter属性]]></title>
    <url>%2F2019%2F01%2F28%2Fcss%2F</url>
    <content type="text"><![CDATA[前言 本文引用张鑫旭大大博客文章《CSS counter计数器(content目录序号自动递增)详解》，一直觉得鑫大大是个被程序员耽误的小说家，他的文章风格大都以浅明深，诙谐幽默，可点击这里查看原文哦。 好了，It’s my show time!在了解到counter之前，想到计数应该属ul，ol标签元素了吧，但它们的递增规则单一，无法实现自定义的递增。而counter属性完美的解决了这个问题，让我们一起来看看吧。首先，使用一个属性前，我们一定得了解一下它的兼容性，曾经被IE兼容性虐哭的我，不得不小心作为一个好用属性的兼容问题。 兼容性 &nbsp;I&nbsp;E&nbsp;&nbsp; Firefox Chrome Safari Opera iOS Safari Android Browser Android Chrome 8.0+ 2.0+ 4.0+ 3.1+ 3.5+ 3.2+ 2.1+ 18.0+ &emsp;&emsp;看到这里是不是心里放松了很多，它的兼容性还是可以的接受的，范围不算局限。 counter的使用题要 CSS计数器只能跟content属性在一起的时候才有作用，而content属性貌似专门用在before/after伪元素上的。于是，就有了，“计数器↔伪元素↔content属性”的铁三角关系 counter成员counter的成员主要有三个： counter-reset（计数器声明及初始值设置） counter-increment（递增规则） counter()/counters(计算结果生成) counter-resetcounter-reset主要有三个属性。 none：默认。不能对选择器的计数器进行重置。 name num：name即标记计数器名称，num即记录计数器初始值。num非必写，默认为0。 inherit：规定应该从父元素继承 counter-reset 属性的值。 counter-incrementcounter-increment主要有三个属性。 none：没有计数器将递增。 name num：name即选择递增的计数器，num即增量。num非必写，默认为1，可以是正数、零或者负数。 inherit：指定counter-increment属性的值，应该从父元素继承。 counter()/counters()这是个方法，不是属性。类似CSS3中才calc()计算。 name：选择递增的计数器。 style：递增的数字样式：阿拉伯数字，罗马数字等，具体如下： list-style-type：disc | circle | square | decimal | lower-roman | upper-roman | lower-alpha | upper-alpha | none | armenian | cjk-ideographic | georgian | lower-greek | hebrew | hiragana | hiragana-iroha | katakana | katakana-iroha | lower-latin | upper-latin string：counters的属性，子序数连接符 注：多个计数器还可同时命名，接下来我们上代码看几个例子。 123456789101112131415161718192021222324252627282930CSS：1. counter-reset属性.xxx &#123; counter-reset: count; /* 计数器名称是'count', 并且默认起始值为0 */&#125; .xxx &#123; counter-reset: count 4; /* 计数器名称是'count', 并且默认起始值为4 */&#125; .xxx &#123; counter-reset: count1 2 count2 3; /* 定义两个计数器'count1'和'count2',默认起始值分别为2和3 */&#125; 2. counter-increment属性.counter &#123; counter-increment: count 2; /*'count'以2阶段递增 */&#125;.counter &#123; counter-increment: count -1; /*'count'以1阶段递减 */&#125;3. counter方法counters(name, style);.counter:before &#123; content: counter(count1) '\A' counter(count2); /*'\A'使用inline水平元素换行*/ white-space: pre; &#125; &emsp;&emsp;接下来看一个完整的例子。效果如图：12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;div class="box"&gt; &lt;div class="list"&gt;一级标题 &lt;div class="box"&gt; &lt;div class="list"&gt;二级标题&lt;/div&gt; &lt;div class="list"&gt;二级标题&lt;/div&gt; &lt;div class="list"&gt;二级标题&lt;/div&gt; &lt;/div&gt; &lt;div class="box"&gt; &lt;div class="list"&gt;二级标题 &lt;div class="box"&gt; &lt;div class="list"&gt;三级标题&lt;/div&gt; &lt;div class="list"&gt;三级标题&lt;/div&gt; &lt;div class="list"&gt;三级标题&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;div class="list"&gt;一级标题&lt;div&gt;&lt;/div&gt;&lt;style&gt;.box &#123; counter-reset: counter; &#125;.toper, .inner &#123; background-color: #eee; margin-left: 20px; &#125;.list:before, .toper:before,.inner:before &#123; counter-increment: counter; &#125;.list &#123; padding-left: 20px;&#125;.inner:before, .list:before, .toper:before &#123; content: counters(counter,'.')'、';&#125;&lt;/style&gt; OK~至此，关于counter的介绍就差不多结束了，可以在实践过程中发现和挖掘更有意思的操作，如果你有什么有趣的神操作，可以给我留言分享哦！啦啦啦~]]></content>
      <categories>
        <category>Front-End Learning</category>
        <category>HTML/CSS</category>
      </categories>
      <tags>
        <tag>Front-End Learning</tag>
        <tag>HTML/CSS</tag>
        <tag>css counter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2019%2F01%2F22%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;数据/字符串处理是工作中经常能用到的，以前的做法大都是通过百度然后修改别人的代码完成字符串处理，一直想系统的跟正则认识一番，于是有了这篇。&emsp;&emsp;再次非常感谢雪峰大大和鑫大大的文章支持，点击以下链接可查看原文。&emsp;&emsp;雪峰大大的 标准对象/RegExp.&emsp;&emsp;鑫大大的 粉丝群第27期JS基础小测答疑文字版&emsp;&emsp;好的，接下来进入正题啦。 正则表达式定义&emsp;&emsp;正则表达式是对字符串操作的一种逻辑公式，用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。举个例子：&emsp;&emsp;’00\d’可以匹配’007’，‘008’，其中‘\d’即匹配数字。 语法元字符 &nbsp;字&nbsp;符&nbsp;&nbsp; 描&nbsp;述 &nbsp;反义字符&nbsp;&nbsp; 描&nbsp;述 $ 匹配输入字符串的结尾位置 ^ 匹配输入字符串的开始位置 . 匹配除换行符 \n 之外的任何单字符 \b 匹配单词边界 \B 匹配不是单词开头或结束的位置 \d 匹配数字 \D 匹配任意非数字的字符 \w 匹配字母，数字，下划线 \W 匹配任意不是字母，数字，下划线 的字符 \s 匹配空格 \S 匹配任意不是空白符的字符 [abc] 匹配包含括号内元素的字符 [^abc] 匹配除了abc以外的任意字符 量词 &nbsp;字&nbsp;符&nbsp;&nbsp; 描&nbsp;述 &nbsp;带?字符&nbsp;&nbsp; 描&nbsp;述 * 重复至少0次 *? 重复任意次,但尽可能少重复 + 重复至少1次 +? 重复至少1次,但尽可能少重复 ? 重复0次或1次 ?? 重复0次或1次,但尽可能少重复 {n} 重复n次 {n,} 重复至少n次 {n,}? 重复至少n次,但尽可能少重复 {n,m} 重复n-m次 {n,m}? 重复n-m次,但尽可能少重复 特殊字符 &nbsp;字&nbsp;符&nbsp;&nbsp; 描&nbsp;述 &nbsp;字&nbsp;符&nbsp;&nbsp; 描&nbsp;述 \cx 匹配由x指明的控制字符。 \f 匹配一个换页符。等价于 \x0c 和 \cL。 ( ) 标记一个子表达式的开始和结束位置。 \n 匹配一个换行符。等价于 \x0a 和 \cJ。 &#124; 指明两项之间的一个选择，或 \r 匹配一个回车符。等价于 \x0d 和 \cM。 [ 标记一个中括号表达式的开始 \s 匹配任何空白字符，包括空格、制表符、换页符等等。 \ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符 \S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。 { 标记限定符表达式的开始。 \t 匹配一个制表符。等价于 \x09 和 \cI。 \v 匹配一个垂直制表符。等价于 \x0b 和 \cK。 举例说明 数字、字母匹配（\d匹配数字，\w匹配任意字母，数字，下划线）可用00\d可以匹配007\d\d\d可以匹配任意三位数字，如：123\w\d\w可以匹配l0l .匹配任意字符，则any.可匹配anya、anyb、anyc、anyd …… 配合上量词再看看\d{3}表示匹配3个数字，例如010\d{3,8}表示3-8个数字，例如1234567 再加上我们的范围[0-9a-zA-Z\_]可以匹配一个数字、字母或者下划线[0-9a-zA-Z\_]+可以匹配至少由一个数字、字母或者下划线组成的字符串，比如a100，0_Z，Py3000等等[a-zA-Z\_][0-9a-zA-Z\_]*可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量[a-zA-Z\_][0-9a-zA-Z\_]{0, 19}更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符） 啊，还有我们的选择字符和定位A|B可以匹配A或B，所以(P|p)ython可以匹配Python或者python^表示行的开头，^\d表示必须以数字开头$表示行的结束，\d$表示必须以数字结束 你可能注意到了，py也可以匹配python，但是加上^py$就变成了整行匹配，就只能匹配py了 字符串的切割 最常用的应该就是split切割了，但是当字符串之间不仅仅是单一字符连接，切割就会出现问题，比如下面的例子 123456789101112 //出现多余空格情况： 'a b c'.split(' '); // ['a', 'b', '', '', 'c']//嗯，无法识别连续的空格，用正则表达式试试：'a b c'.split(/\s+/); // ['a', 'b', 'c']//无论多少个空格都可以正常分割。加入,试试：'a,b, c d'.split(/[\s\,]+/); // ['a', 'b', 'c', 'd']//再加入;试试：'a,b;; c d'.split(/[\s\,\;]+/); // ['a', 'b', 'c', 'd']//如果用户输入了一组标签，下次记得用正则表达式来把不规范的输入转化成正确的数组。 字符串的分组应用除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group）。比如：^(\d{3})-(\d{3,8})$分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码： 123var re = /^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$/;re.exec('010-12345'); // ['010-12345', '010', '12345']re.exec('010 12345'); // null 如果正则表达式中定义了组，就可以在RegExp对象上用exec()方法提取出子串来。exec()方法在匹配成功后，会返回一个Array，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。exec()方法在匹配失败时返回null。 提取子串非常有用。来看一个更凶残的例子： 12var re = /^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$/;re.exec('19:05:30'); // ['19:05:30', '19', '05', '30'] 这个正则表达式可以直接识别合法的时间。但是有些时候，用正则表达式也无法做到完全验证，比如识别日期： 1var re = /^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$/; 对于’2-30’，’4-31’这样的非法日期，用正则还是识别不了，或者说写出来非常困难，这时就需要程序配合识别了。 以下内容参见鑫大大博客内容： 中英文之间需要增加空格首先，我们的思路应该是“中文”、“英文”、“空格”，于是我们可得到&emsp;/(中文+英文+|英文+中文+)/g&emsp;这样的符号表达转换成正则符号即:&emsp;/([\u4e00-\u9fa5]+[A-Za-z]+|[A-Za-z]+[\u4e00-\u9fa5]+)/g其中[\u4e00-\u9fa5]表示中文字符匹配；[A-Za-z]表示全部的英文字母。斜杠后面的g表示全局匹配，除了g，还有i和m。其中i表示不区分大小写，m表示支持多行匹配。这里的括号和加号可化简，则最终可表达为：&emsp;/[\u4e00-\u9fa5][a-z]|[a-z][\u4e00-\u9fa5]/gi 全角标点与其他字符之间不加空格这里如果直接用正则表达式，会显得冗余且不易懂，故使用RegExp对象简化 123456// 全角标点字符们 var strPunct = '！（）【】『』「」《》“”‘’；：，。？、'; // 使用管道符连接 var regPunct = strPunct.split('').join('|'); // 此时的正则表达式 new RegExp('['+ regPunct +'] +| +['+ regPunct +']', 'g'); 这样就显得简洁多了其中，空格使用普通空格字符进行匹配的，而不是\s，这样可以避免把换行符也过滤掉了 不重复使用标点符号这里的标点指中文标点，因为英文标点不重复，有些不切实际，例如空字符串’’，就是合法的重复标点。使用正则表达式： 1/(\~|\`|\!|\[|\]|\&#123;|\&#125;|\;|\:|\"|\'|\,|\&lt;|\.|\&gt;|\/|\?|\！|\·|\【|\】\「\」|\；|\：|\“|\”|\，|\《|\。|\》|\、|\？)\1+/g 使用RegExp对象简化： 1new RegExp(`($&#123;regPunct&#125;)\\1+`, 'g') 这样就是不使用重复中文标点了。其中，这里的\1有必要好好说下。\1表示捕获匹配，表示捕获第一个分组括号中匹配的值，你可以理解为代称。在正则表达式中，每一个分组括号()都自带一个看不见的序号，从前往后依次是分组一，分组二，分组三……这里的\1就表示匹配的第一个标点，后面跟了个+则表示，这里重复标点2个或多个都匹配。捕获分组不仅存在于正则表达式中，当我们使用replace方法进行正则替换的时候，也存在与替换方法中，使用美元符号$外加数字表示，例如前后空格过滤trim()方法的简易polyfill： 123456if (!''.trim) &#123; String.prototype.trim = function () &#123;// $1表示第一个()中匹配的值return this.replace(/^\s*(.*?)\s*$/, '$1'); &#125;;&#125; 其中’$1’并不是替换成字符串$1意思，而是替换成第一个()中匹配的值，在这里表示首尾空格以外的值。 如果我们需要对捕获分组内容进行额外处理，可以把第二个参数作为function处理，例如： 12345this.replace(/^\s*(.*?)\s*$/, function (matches, $1) &#123; // matches表示完整匹配内容（包括前后空格） // $1则表示第一个()中匹配的值 // 此时就可以对$1进行处理，返回我们需要的值&#125;) 破折号前后需要增加一个空格这个比较简单，可直接获得： 1/\S——|——\S/g 使用全角中文标点正则表达式 1/([^A-Za-z][\~|\`|\!|\[|\]|\&#123;|\&#125;|\;|\:|\"|\'|\,|\&lt;|\.|\&gt;|\/|\?][^A-Za-z])/g 使用RegExp对象处理： 12345var strPunctHalf = '!()[]"\';:,.?';// 不同于全角字符，半角字符需要加转义var regPunctHalf = strPunctHalf.split('').join('|\\');// 此时的正则表达式new RegExp(`[\u4e00-\u9fa5][a-z]*( *[$&#123;regPunctHalf&#125;] *)|( *[$&#123;regPunctHalf&#125;] *)[a-z]*[\u4e00-\u9fa5]`, 'gi'); 数字使用半角/[\uFF10-\uFF19]+/g 遇到完整的英文整句，其內容使用半角标点正则表达式 1/(\「[A-Za-z\s\~|\`|\!|\;|\:|\"|\'|\,|\&lt;|\.|\&gt;|\/|\?]*[\！|\·|\；|\：|\“|\”|\，\。|\、|\？][^\」]*\」)|(\《[A-Za-z\s\~|\`|\!|\;|\:|\"|\'|\,|\&lt;|\.|\&gt;|\/|\?]*[\！|\·|\；|\：|\“|\”|\，\。|\、|\？][^\》]*\》)/g RegExp对象处理: 1new RegExp(`([a-z]+[$&#123;regPunct&#125;|\\s])+[a-z]*([$&#123;regPunct&#125;|\\s][a-z]+)+`, 'gi') &emsp;&emsp;正则表达式的介绍就先到这里啦，怎么样，动手使用吧~~~]]></content>
      <categories>
        <category>Front-End Learning</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Front-End Learning</tag>
        <tag>JavaScript</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[敢问施主因何而来]]></title>
    <url>%2F2019%2F01%2F16%2Fhello-world%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;个人习惯，来到一个新的地方总是喜欢先来个开篇，阐述一下因由。&emsp;&emsp;作为一个思绪如钢丝球的伪文艺女青年，我总能在某个奇怪的点在肚子里用仅有的墨水哗哗哗的长篇论述一番，并自我感觉异常良好，这篇淡墨水文或是段子，或是感思，或是记人，或是叙事，有时也可能仅是想描个景。每每这时我都特别的想发个朋友圈或是空间说说反馈我难以抑制的感觉，但又怕显得琐碎，矫情，于是默默地吞进肚子，然后被消化到淡忘。&emsp;&emsp;于是来此，畅叙一番，不为什么，就怕话痨的我被程序员的静默给憋出内伤，哈哈哈哈哈哈哈哈哈哈啊。&emsp;&emsp;当然，也希望在这里能够记录我的学习历程，平常会有些记笔记的习惯，但是缺少整理和系统的归纳，再者希望通过公共学习和更多的人交流，发现自己的陋习和问题。&emsp;&emsp;这里大致给自己列了一个目录的提纲，诶哟喂，希望能够满满的丰富起来呀~~~&emsp;&emsp;Fighting！ 胡啦啦家的大墨池 碎碎念 记人 叙事 矫情话二三 Front-End Learning HTML/CSS JavaScript Vue React Angular Node DataBase Webpack Else 啦啦 is here 音乐 电影 字词句段篇章 电视剧 彩铅 美食 旅游 蹦跶蹦跶dance~（估计这会是个空置项，哈哈哈 &emsp;&emsp;最后！首篇福利，给大家看一张我超爱的图片，超级cute！！！因而最后的结果被我截图制成了头像，哇啊啊啊啊，老夫的少女心啊。]]></content>
      <categories>
        <category>胡啦啦家的大墨池</category>
        <category>碎碎念</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
      </tags>
  </entry>
</search>
